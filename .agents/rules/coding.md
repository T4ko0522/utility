# Agent Coding Rules

## Core

### 0. 着手手順（実装前に必ず）
- 目的 / 期待する入出力 / 制約（互換性・期限・性能など）を明文化する
- 影響範囲を宣言する（触るファイル / 触らないファイル）
- 不明点は「仮定」として列挙し、仮定に依存する変更は最小にする
- 既存挙動を壊しやすい箇所（認可・永続化・状態遷移・課金/重要計算・外部I/O）を先に特定する

### 1. 変更の原則
- 目的達成に不要な変更はしない（ついでリファクタは禁止。必要なら別タスク/別PR）
- 決めた責務を越えない（責務境界を跨ぐ修正は分割を検討）
- 破壊的変更は避け、避けられない場合は段階移行（移行手順・互換期間・ロールバック）を用意する
- 既存の挙動変更は「意図 / 影響範囲 / 移行」を明記する

### 2. アーキテクチャ規律（汎用）
- 境界（例: UI / API / Domain / Infra）を跨ぐロジックは、原則 Domain（または Usecase）側に寄せる
- どこに置くか迷う実装は、先に責務を書いてから配置を決める
- 層が存在する場合は「上位 → 下位」の依存のみ（例外は理由・影響・代替案を明記）

### 3. エラー処理・例外 / 失敗設計
- 失敗ケースを「起きない前提」にしない（異常系を設計に含める）
- 例外・エラーの型（カテゴリ）を揃える（呼び出し元が判断できる形にする）
- エラーの握りつぶし禁止（握るなら代替結果・通知・メトリクスなどを伴う）
- 失敗時ログは「原因が追える情報」を含める（ただし機微情報は除く）
- リトライ前提の処理は冪等キーを設ける（冪等のスコープを明記）
- 二重実行・部分失敗を想定する（重複登録・二重課金・二重送信を防ぐ）

### 4. データと状態の整合性
- キャッシュは “正” にならない（正は永続ストア/一次ソース）
- 状態遷移を分散させない（遷移関数・遷移表・単一の責務へ集約）
- ID は一貫した生成戦略（生成場所・形式・衝突回避を統一）
- “いつのデータか” を追えるようにする（updated_at / version / etag 等）

### 5. セキュリティ
- バリデーションは境界で行い、内部は前提を固定する（境界の定義を明確に）
- 認可は必ずサーバー側で成立させる（クライアント前提にしない）
- 秘密情報は「直書き禁止・ログに出さない・例外メッセージにも含めない」
- ログ/トレースの機微情報対策
  - token / cookie / authorization header は必ずマスク
  - PII（メール/電話/住所/IP/自由入力など）は原則出さない（必要なら部分マスク）

### 6. ログ・監視・デバッグ容易性
- “何が起きたか” と “なぜ起きたか” が追えるログ（構造化を優先）
- 主要処理は「成功/失敗/所要時間」を取れる構造にする
- 相関できる識別子を持たせる（request_id / job_id など）

### 7. テスト・検証（最低ライン）
- 重要ロジック（認可/永続化/状態遷移/外部I/O/重要計算）は最低 1 ケース以上テストを追加
- バグ修正は「再現テスト → 修正 → テスト緑」を原則
- 境界値 or 異常系を最低 1 つ含める
- テストが書けない変更は、設計（責務分割/依存注入/純粋関数化）を見直す

### 8.  外部I/O（DB・HTTP・Queue など）
- タイムアウトを必ず設定する（無限待ち禁止）
- リトライは条件を明示し、可能ならバックオフ（無差別リトライ禁止）
- 一覧取得は上限・ページング・バッチを検討（DoS/N+1 を避ける）

### 9. パフォーマンス
- 体感が悪くなる箇所だけ最適化（それ以外は可読性優先）
- 推測での最適化禁止（計測・根拠を残す）
- 重い処理は非同期/ジョブ化を検討（失敗時の再実行と冪等もセット）

### 10. 依存関係
- 追加は最小限（標準機能・既存依存で足りるなら増やさない）
- 追加するなら理由を明文化（何を解決し、何を増やすか）
- 可能なら「代替案（採用しなかった理由）」を 1 行残す

### 11. 完了条件
- ビルド / 型チェック / lint / テスト（既存含む）が通る
- 影響範囲の動作確認を実施（最短ルートでよいが、確認点を明記）
- 破壊的変更なら移行手順・互換期間・ロールバックを記載
- 追加依存があるなら理由・影響（サイズ/運用/セキュリティ）を記載
